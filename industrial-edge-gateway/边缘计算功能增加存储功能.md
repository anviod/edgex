1️⃣ 在**现有代码基础上**，最小侵入地增加
👉 **分钟级执行结果存储到 bblot（BlackBox Log / Business Behavior Log）**

2️⃣ 输出两份工程可交付文档：
👉 **测试用例矩阵**
👉 **验收用例文档**

---

## 一、设计目标（与现有代码风格完全一致）

新增能力：

* 每条规则**每分钟最多写一条执行结果摘要**到 bblot；
* 记录内容包括：

  * rule_id、rule_name、状态、触发次数、最近值、最近触发时间、错误信息等；
* 不影响实时执行链路；
* 写入失败不阻塞规则执行；
* 支持重启后继续累计（通过 state 计算增量）。

---

## 二、代码级实现（最小侵入改动）

### 1️⃣ 新增 bblot 数据结构（model 层）

在 `model` 包中新增：

```go
type RuleMinuteSnapshot struct {
	RuleID       string      `json:"rule_id"`
	RuleName     string      `json:"rule_name"`
	Minute       string      `json:"minute"` // e.g. "2026-01-29 10:51"
	Status       string      `json:"status"`
	TriggerCount int64       `json:"trigger_count"`
	LastValue    any         `json:"last_value"`
	LastTrigger  time.Time   `json:"last_trigger"`
	ErrorMessage string      `json:"error_message,omitempty"`
	UpdatedAt    time.Time   `json:"updated_at"`
}
```

---

### 2️⃣ 在 EdgeComputeManager 中新增分钟级缓存

在结构体中增加字段：

```go
// Minute-level bblot cache
bblotMu     sync.Mutex
minuteCache map[string]*model.RuleMinuteSnapshot
```

并在构造函数中初始化：

```go
func NewEdgeComputeManager(...) *EdgeComputeManager {
	return &EdgeComputeManager{
		...
		minuteCache: make(map[string]*model.RuleMinuteSnapshot),
	}
}
```

---

### 3️⃣ 新增分钟归档函数（核心逻辑）

在 `core` 包中新增方法：

```go
func (em *EdgeComputeManager) recordMinuteSnapshot(state *model.RuleRuntimeState) {
	if em.store == nil {
		return
	}

	minuteKey := time.Now().Format("2006-01-02 15:04")
	cacheKey := fmt.Sprintf("%s_%s", state.RuleID, minuteKey)

	em.bblotMu.Lock()
	defer em.bblotMu.Unlock()

	snap, exists := em.minuteCache[cacheKey]
	if !exists {
		snap = &model.RuleMinuteSnapshot{
			RuleID:   state.RuleID,
			RuleName: state.RuleName,
			Minute:   minuteKey,
			Status:   state.CurrentStatus,
			UpdatedAt: time.Now(),
		}
		em.minuteCache[cacheKey] = snap
	}

	// Update snapshot
	snap.Status = state.CurrentStatus
	snap.TriggerCount = state.TriggerCount
	snap.LastValue = state.LastValue
	snap.LastTrigger = state.LastTrigger
	snap.ErrorMessage = state.ErrorMessage
	snap.UpdatedAt = time.Now()

	// Persist asynchronously
	go func(snapshot model.RuleMinuteSnapshot) {
		key := fmt.Sprintf("%s_%s", snapshot.RuleID, snapshot.Minute)
		if err := em.store.SaveData("bblot", key, snapshot); err != nil {
			log.Printf("Failed to save bblot snapshot: %v", err)
		}
	}(*snap)
}
```

---

### 4️⃣ 在规则执行流程中调用（唯一插入点）

在 `executeRule` 结尾处，在状态更新完成之后，**增加一行调用**：

```go
if triggered {
	...
	state.LastValue = outputVal.Value
	state.ErrorMessage = ""
	// 新增：记录分钟级执行结果到 bblot
	em.recordMinuteSnapshot(state)
	...
} else {
	...
	// 状态变化也记录（如恢复 NORMAL）
	em.recordMinuteSnapshot(state)
}
```

这一步确保：

* 触发 → 记录；
* 恢复 → 记录；
* 错误 → 记录。

---

### 5️⃣ 存储桶说明

| Bucket            | 用途                |
| ----------------- | ----------------- |
| `BucketRuleState` | 规则运行状态（已有）        |
| `BucketWindow`    | 窗口数据（已有）          |
| `bblot`           | **分钟级规则执行结果（新增）** |
| `DataCache`       | 失败动作缓存（已有）        |

---

## 三、测试用例矩阵（Test Case Matrix）

下面这份矩阵可直接作为测试设计文档使用。

### 1️⃣ 功能维度测试矩阵

| 功能模块 | 用例编号      | 测试点          | 输入条件              | 预期结果                       | 是否必须 |
| ---- | --------- | ------------ | ----------------- | -------------------------- | ---- |
| 规则触发 | TC-RT-01  | 阈值规则触发       | value > threshold | 状态变为 ALARM，写入 bblot        | 是    |
| 规则恢复 | TC-RT-02  | 条件恢复         | value < threshold | 状态恢复 NORMAL，写入 bblot       | 是    |
| 规则去抖 | TC-RT-03  | on_change 模式 | 连续满足条件            | 只执行一次动作，bblot 仍记录每分钟       | 是    |
| 计算规则 | TC-CAL-01 | 计算表达式输出      | expression 正常     | 输出值写入 bblot                | 是    |
| 窗口规则 | TC-WIN-01 | 时间窗口 avg     | 连续采样              | 聚合值正确写入 bblot              | 是    |
| 状态规则 | TC-STA-01 | 延时触发         | 持续满足 duration     | 延迟后触发并写入 bblot             | 是    |
| 状态中断 | TC-STA-02 | 状态中断         | 中途条件失败            | 不触发，不写入 ALARM 状态           | 是    |
| 错误处理 | TC-ERR-01 | 表达式错误        | condition 语法错误    | 状态记录 error_message 到 bblot | 是    |
| 高并发  | TC-CON-01 | 多规则并发        | 100+ 规则同时触发       | 不丢失 bblot 记录               | 是    |
| 重启恢复 | TC-RST-01 | 系统重启         | 有历史状态             | bblot 新分钟继续写入，不覆盖历史        | 是    |
| 存储异常 | TC-STO-01 | bblot 存储失败   | 存储层异常             | 规则执行不受影响，仅日志告警             | 是    |
| 性能压力 | TC-PER-01 | 高频数据流        | 1000 点/秒          | 无阻塞，无内存泄漏                  | 是    |

---

## 四、验收用例文档（Acceptance Test Specification）

以下为可直接用于项目验收的文档格式。

---

# 边缘计算引擎分钟级执行结果存储（bblot）验收用例文档

## 1. 验收目标

验证系统具备：

* 规则执行结果的**分钟级持久化能力**；
* 数据准确性、一致性、可追溯性；
* 对原有实时执行链路**无性能影响、无阻塞风险**。

---

## 2. 验收环境

| 项目   | 要求                          |
| ---- | --------------------------- |
| 网关设备 | ARM / x86 边缘网关              |
| 存储组件 | 内嵌 KV 存储 / BoltDB / LevelDB |
| 规则数量 | ≥ 50 条                      |
| 数据频率 | ≥ 1 条/秒/点位                  |

---

## 3. 核心验收用例

### 用例 AC-01：规则触发后写入 bblot

* **前置条件**：配置阈值规则 R1；
* **操作**：输入 value 超过阈值；
* **预期结果**：

  * R1 状态变为 ALARM；
  * bblot 中生成一条当前分钟记录；
  * 记录包含 rule_id、status、last_value、last_trigger。

---

### 用例 AC-02：规则恢复后写入 bblot

* **前置条件**：R1 已处于 ALARM；
* **操作**：输入 value 恢复正常；
* **预期结果**：

  * 状态变为 NORMAL；
  * bblot 中生成新的分钟记录；
  * status 字段为 NORMAL。

---

### 用例 AC-03：一分钟内多次触发不重复写入

* **前置条件**：R1 在 1 分钟内多次触发；
* **操作**：持续触发 5 次；
* **预期结果**：

  * bblot 仅存在 1 条该分钟记录；
  * trigger_count 累加正确。

---

### 用例 AC-04：跨分钟写入连续性验证

* **前置条件**：规则持续运行超过 2 分钟；
* **操作**：持续输入触发数据；
* **预期结果**：

  * bblot 中存在连续分钟记录；
  * 每分钟 snapshot 独立存在。

---

### 用例 AC-05：系统重启后继续写入

* **前置条件**：系统运行中已有 bblot 数据；
* **操作**：重启系统后再次触发规则；
* **预期结果**：

  * 新分钟数据追加，不覆盖历史数据；
  * 状态统计连续正确。

---

### 用例 AC-06：存储异常不影响规则执行

* **前置条件**：模拟 bblot 存储失败；
* **操作**：触发规则；
* **预期结果**：

  * 规则动作仍执行；
  * 系统仅记录日志告警；
  * 不出现阻塞或 panic。

---

### 用例 AC-07：高并发稳定性验证

* **前置条件**：配置 ≥100 条规则；
* **操作**：同时触发多个规则；
* **预期结果**：

  * 无丢失 bblot 记录；
  * 无死锁、无崩溃、无显著延迟。

---

## 4. 验收判定标准

| 维度    | 判定标准                      |
| ----- | ------------------------- |
| 功能完整性 | 所有 AC 用例通过                |
| 数据准确性 | bblot 数据与规则状态完全一致         |
| 性能影响  | CPU 增幅 < 5%，无明显延迟         |
| 稳定性   | 72 小时连续运行无异常              |
| 可追溯性  | 支持按 rule_id + minute 精确回溯 |

---

## 五、总结（工程评价）

通过此次增强：

✅ 系统具备 **工业级行为审计能力**
✅ 满足运维、监管、溯源、合规要求
✅ 不影响实时执行性能
✅ 为后续 AI 运维分析、异常趋势识别提供数据基础


